import {useEffect, useState} from 'react';

/**
 * Finds all trees above or adjacent to the given element that do not contain the given element or element tree.
 *
 * For example, in the below tree, if we wanted the `#nested-modal` to be the only accessible element tree, we could
 * utilize this function to apply the `inert` attribute to each tree that doesn't contain any elements we'll need access
 * to.
 *
 * ```
 * body
 *   └─╴div#root
 *        ├─╴header
 *        │    ├─╴svg.logo
 *        │    └─╴h1
 *        ├─╴main
 *        │    ├─╴section#nested-modal
 *        │    │    ├─╴h1
 *        │    │    └─╴button
 *        │    └─╴p
 *        └─╴footer
 *             └─╴a
 * ```
 *
 * In this tree, the elements `p`, `header`, and `footer` would be produced by this function when calling it like so:
 * ```js
 * const modal = document.getElementById('nested-modal')
 * forEachNonDescendantTree(modal, element => element.inert = true)
 * ````
 *
 * @param {HTMLElement} element
 * @param {function(HTMLElement): void} callback
 */

export function forEachNonDescendantTree(element, callback) {
	let currentElement = element;
	const root = document.getElementById('root');

	while (currentElement !== root) {
		let previous = currentElement.previousElementSibling;
		let next = currentElement.nextElementSibling;

		while (previous) {
			callback(previous);
			previous = previous.previousElementSibling;
		}

		while (next) {
			callback(next);
			next = next.nextElementSibling;
		}

		currentElement = currentElement.parentElement;
	}
}

/**
 * Immutably removes the item at the specified index from the array.
 *
 * @template T
 * @param {Array<T>} array
 * @param {number} index
 * @returns {Array<T>}
 */
export function removeFromArray(array, index) {
	return array.slice(0, index).concat(array.slice(index + 1));
}

/**
 * Immutably replaces the item at the specified index with a new value
 * generated by transforming the data through the provided callback.
 *
 * @template T
 * @template O
 * @param {Array<T>} array
 * @param {number} index
 * @param {function(T): O}callback
 * @returns {Array<T|O>}
 */
export function replaceInArray(array, index, callback) {
	return array.slice(0, index).concat(callback(array[index]), array.slice(index + 1));
}

/**
 * Returns whether or not the user is at the top of the page or not.
 * @returns {'top' | 'scrolled'}
 */
export function useScrollStatus() {
	const [scrollStatus, setScrollStatus] = useState('top');

	useEffect(() => {
		function handler() {
			setScrollStatus(() => {
				if (window.scrollY > 0) return 'scrolled';
				return 'top';
			});
		}

		window.addEventListener('scroll', handler);
		return () => {
			window.removeEventListener('scroll', handler);
		};
	}, []);

	return scrollStatus;
}
